/* eslint no-console:0 */
'use strict';

/* Architecture Note #1: Generating the API

Since we have a OpenAPI file, we are generating
 the API to avoid boilerplate code.

A small article (in french) about why and how
 to do that:
http://insertafter.com/fr/blog/generation_api_cliente.html

*/

const camelCase = require('camel-case');
const path = require('path');
const fs = require('fs');
const {
  flattenOpenAPI,
  getOpenAPIOperations,
} = require('@whook/http-router/dist/utils');
const buildVersion = require(path.join(__dirname, '..', 'package.json'))
  .version;
const apiVersion = require(path.join(
  __dirname,
  '..',
  'src',
  'openapi.api.json',
)).info.version;

flattenOpenAPI(require('../src/openapi.api.json'))
  .then(API => {
    const operations = getOpenAPIOperations(API);
    const content = `
// WARNING: This file is automatically generated
// do not change it in place it would be overriden
// in the next build
'use strict';

const querystring = require('querystring');
const axios = require('axios');
const {
  cleanHeaders,
  cleanQuery,
  sortMultipleQuery, // eslint-disable-line
} = require('./lib');

/**
 * ${API.info.description}
 * @module API
 * @version ${API.info.version}
 */
const API = {
  ${operations.map(({ operationId }) => operationId).join(',\n  ')},
};

${operations
  .map(operation => {
    const { path, method, operationId, parameters, requestBody } = operation;

    return `
/**
 * ${operation.summary}
 * @param {Object} parameters
 * The parameters to provide (destructured)${
   requestBody
     ? `
  @param body The request body
`
     : ''
 }${(parameters || [])
      .filter(
        p =>
          !['X-API-Version', 'X-SDK-Version', 'X-APP-Version'].includes(p.name),
      )
      .map(
        parameter => `
 * @param {${
   parameter.schema
     ? parameter.schema.oneOf
       ? [...new Set(parameter.schema.oneOf.map(s => s.type))].join('|')
       : parameter.schema.type
     : parameter.type
 }} ${parameter.required ? `` : `[`}parameters.${camelCase(parameter.name)}${
          parameter.required ? `` : `]`
        }
 * ${parameter.description}`,
      )}
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
function ${operationId}(${
      requestBody || (parameters && parameters.length)
        ? `{ ${
            requestBody
              ? `
      body,`
              : ''
          }${parameters
            .filter(p => !['X-API-Version', 'X-SDK-Version'].includes(p.name))
            .map(parameter => {
              const variableName = camelCase(parameter.name);

              return `\n  ${variableName},`;
            })
            .join('')}} = {}`
        : '_'
    }, options) {

  ${(parameters || [])
    .map(parameter => {
      if (parameter.required) {
        return `if( ${camelCase(parameter.name)} == null) {
        throw new Error('Missing required parameter : ${camelCase(
          parameter.name,
        )}. Value : ' +  ${camelCase(parameter.name)});
      }
      `;
      }
    })
    .join('')}

  const method = '${method}';
  let urlParts = [${path
    .split('/')
    .filter(identity => identity)
    .map(part => {
      const result = /^{([a-z0-9]+)}$/gi.exec(part);

      if (result) {
        return `
    ${camelCase(result[1])},`;
      }
      return `
    '${part}',`;
    })
    .join('')}
  ];
  let headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '${apiVersion}',
    'X-SDK-Version': '${buildVersion}',${(parameters || [])
      .filter(p => 'header' === p.in)
      .filter(p => !['X-API-Version', 'X-SDK-Version'].includes(p.name))
      .map(
        parameter => `
    '${parameter.name}': ${camelCase(parameter.name)},`,
      )
      .join('')}
  });
  let qs = cleanQuery({${(parameters || [])
    .filter(p => 'query' === p.in)
    .map(
      parameter => `
    ${parameter.name}: ${camelCase(parameter.name)}${
        parameter.ordered ? '.sort(sortMultipleQuery)' : ''
      },`,
    )
    .join('')}
  });
  let data = ${requestBody ? 'body' : '{}.undef'};

  return axios(Object.assign({
    baseURL: '${API.servers[0]}',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));
}`;
  })
  .join('\n')}

module.exports = API;
`;

    return new Promise((resolve, reject) => {
      fs.writeFile('src/index.js', content, err => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
  })
  .catch(err => {
    console.error(err.stack);
    process.exit(1);
  });
